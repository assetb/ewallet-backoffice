# Техническое задание

## **Техническое задание (ТЗ) на создание фронтового веб-приложения (ФП)**

## 1. Введение

**1.1. Цель проекта**
Создать фронтовое веб-приложение (ФП), обеспечивающее взаимодействие пользователя с двумя бэк-эндами: «Платежный шлюз» (ПШ) и «Электронный кошелек» (ЭК). Приложение должно предоставлять удобный графический интерфейс для выполнения операций в соответствии с ролями (менеджер, финансист, руководитель) и запрашивать/отображать данные из соответствующих систем.

**1.2. Область применения**
ФП предназначено для сотрудников финансового отдела и менеджеров компании Asset. С его помощью:

* Загружать пакеты платежей в систему ЭК через ПШ;
* Осуществлять заявки на гашение электронных денег (ЭД) мерчантов;
* Подтверждать гашение на уровне руководителя;
* Просматривать историю платежей, гашений и эмиссий;
* Контролировать баланс;
* Выполнять другие функциональные операции, которые могут быть добавлены в будущем.

**1.3. Общие ограничения**

* ФП не имеет собственной базы данных. Все постоянные данные (списки мерчантов, запросы, история операций, учётные записи) хранятся или на жестком диске сервера в виде текстовых файлов, или запрашиваются из бэкендов ПШ и ЭК.
* Для хранения логинов и паролей пользователей на стороне ФП будет использоваться файл `users.txt` (или аналогичный), хранящий минимальный объём информации.
* Авторизация и аутентификация пользователей осуществляются локально (на уровне фронта + простая проверка по файлу) с последующей привязкой к ролям.
* Между ФП и обоими бэкендами (ПШ и ЭК) должно быть организовано безопасное взаимодействие по HTTPS.

---

## 2. Цели и задачи

1. **Безопасная авторизация пользователей**

   * Поддержка мульти-ролевой модели (менеджер, финансист, руководитель; возможность расширения).
   * Ограничение вызовов API ПШ/ЭК только авторизованными пользователями в соответствии с их ролью.

2. **Функциональные модули по ролям**

   * Менеджер: пакетная загрузка платежей в БД ЭК через API ПШ и отображение результатов.
   * Финансист: формирование и отправка заявки на гашение ЭД мерчанта; просмотр текущих запросов, проведённых гашений/эмиссий, баланса.
   * Руководитель: просмотр заявок на гашение, подтверждение гашения, просмотр истории гашений/эмиссий, баланса.

3. **Интеграция с внешними системами (ПШ и ЭК)**

   * Отправка файлов с платежами в ПШ;
   * Запрос списков мерчантов, баланса, истории операций из ПШ;
   * Запрос данных из БД ЭК (отображение платежей);
   * Передача запросов на подтверждение гашения (через собственный бэк ФП → ПШ).

4. **Лёгкость сопровождения и расширяемость**

   * Модульная структура фронта, позволяющая добавлять новые роли/функции без полной переработки.
   * Единственное хранилище для настроек/учётных данных (текстовые файлы), минимальный объём.

5. **Юзабилити и понятный интерфейс**

   * Раздельные экраны/вкладки для каждого функционального блока;
   * Удобная навигация и отображение результатов: списки, формы, кнопки, текстовые поля.

---

## 3. Функциональные требования

### 3.1. Авторизация пользователей

* **3.1.1. Вход по логину/паролю**

  * При старте ФП отображается страница «Login»:

    * Поля «Логин» и «Пароль».
    * Кнопка «Войти».
    * При нажатии проверяется введённая пара «логин/пароль» по файлу на сервере (локальный REST-эндпоинт ФП: `/api/auth`).
    * Если совпадение найдено, сервер возвращает объект `{ userId, role }`. На клиенте сохраняется JWT-токен (или аналогичный идентификатор сессии) в `sessionStorage` (или `cookie`, отмеченное как Secure+HttpOnly).
    * Если неверные данные, показывается ошибка «Неверный логин или пароль».

* **3.1.2. Роли пользователей**

  * Роли:

    * `manager` (менеджер)
    * `finance` (финансист)
    * `supervisor` (руководитель)
    * Возможность добавления новых ролей в будущем.
  * После успешного входа пользователь попадает на «Dashboard» (главный экран), где исходя из роли видим лишь разрешённый функционал.

* **3.1.3. Защита роутов**

  * Каждый роут (URL) ФП защищён middleware, который проверяет наличие валидного токена и роль.
  * Примеры URL: `/manager/payments`, `/finance/redemption`, `/supervisor/approvals`, и т.д.
  * Если пользователь без соответствующей роли попытается зайти на недоступный URL, переадресация на страницу «403 Forbidden» или на «Dashboard» с уведомлением.

---

### 3.2. Функционал менеджера (role = `manager`)

**Основная задача**: пакетная загрузка платежей в БД ЭК через API ПШ.

#### 3.2.1. Сценарий использования

1. Менеджер авторизуется и открывает вкладку «Загрузка платежей».
2. ФП делает запрос к локальному API ФП `/api/manager/uploaded-files`, чтобы получить список уже загруженных файлов (хранится в файле `uploaded_files.txt` на сервере).
3. Список файлов отображается в виде упорядоченного списка (table или list) с названиями файлов и датой загрузки.
4. Над списком выводится кнопка «Загрузить файл».
5. При нажатии на «Загрузить файл» открывается системное окно выбора файла (dialog `<input type="file">`).
6. После выбора файл (CSV, XML или другой формат) отправляется POST-запрос на локальный API ПФ:

   ```
   POST /api/manager/upload  
   Content-Type: multipart/form-data
   Body:
     - file: выбранный файл
     - uploaderId: userId (из токена)
   ```
7. Локальный бэк ФП (endpoint `/api/manager/upload`) перенаправляет (прокси) файл в API «Платежного Шлюза» (ПШ), например:

   ```
   POST https://payment-gateway.company/api/payments/batch-upload
   Headers: { Authorization: Bearer <PШ-токен> }
   Body: { file }
   ```
8. ПШ обрабатывает файл, загружает платежи в свою БД и возвращает JSON с результатом (успех/ошибка, количество записей, список ошибок).
9. Локальный бэк ФП сохраняет в файл `uploaded_files.txt` новую запись (имя файла, дата, uploaderId, статус).
10. Фронт принимает ответ и отображает сообщение:

    * В случае успеха: «Файл `<имя>` успешно загружен. Загружено `<N>` платежей.»
    * Если есть ошибки: «Файл `<имя>` загружен с ошибками: …».
11. После успешной загрузки обновляется список загруженных файлов (делается новый запрос `/api/manager/uploaded-files`).

#### 3.2.2. UI-описание

* **Страница «Загрузка платежей»** (`/manager/payments`):

  * **Заголовок**: «Загрузка платежей (Менеджер)».
  * **Список загруженных файлов**:

    * Таблица или список (`<table>` / `<ul>`), колонки: «№», «Имя файла», «Дата загрузки», «Статус», «Утвержден/Отклонен (опционально)».
    * Возможность пролистывать историю (пагинация, если > 50 записей).
  * **Кнопка «Загрузить файл»**:

    * Выделена цветом (например, `primary`), по нажатию открывается диалог выбора файла.
  * **Текстовое поле для результата**:

    * `<textarea readonly>` или `<div>` внизу экрана, где отображается сообщение от последней загрузки.
  * **Логика**: при загрузке показывать индикатор загрузки (spinner), затем результат.

#### 3.2.3. Локальные файлы (серверные)

* `uploaded_files.txt`

  * Формат: каждый файл — отдельная строка:

    ```
    <имя_файла>;<дата_в_формате_ISO>;<uploaderId>;<status>;<загруженных_записей>;<количество_ошибок>
    ```
  * Пример:

    ```
    payments_2025-06-01.csv;2025-06-01T10:23:45;user123;SUCCESS;2500;0
    payments_2025-05-28.csv;2025-05-28T14:11:12;user456;ERROR;1800;5
    ```

---

### 3.3. Функционал финансиста (role = `finance`)

**Основная задача**: формировать и отправлять запрос на гашение ЭД мерчанту, а также просматривать связанные данные (запросы, историю гашений, эмиссий и баланс).

#### 3.3.1. Сценарий использования

1. Финансист авторизуется, открывает вкладку «Гашение ЭД».

2. При загрузке страницы ФП делает три запроса к локальному API ФП:

   1. `/api/finance/merchants` → получить список наименований мерчантов (файл `merchants.txt` хранится на сервере).
   2. `/api/finance/redemption-requests` → получить текущие заявки на гашение (файл `redemption_requests.txt`).
   3. `/api/finance/history` → получить истории гашений и эмиссий (файл `history.txt`).
   4. `/api/finance/balance` → получить текущий баланс (через прокси-запрос к ПШ).

3. **Формирование запроса на гашение**:

   * Пользователь в форме указывает:

     * Сумму (числовое поле)
     * Выбор мерчанта (выпадающий список, загруженный из `merchants.txt`).
   * Нажимает «Провести гашение».
   * ФП проверяет заполнение полей (валидация: сумма > 0, выбран мерчант).
   * Делает `POST /api/finance/redemption-requests` с телом `{ merchantId, amount, requesterId }`.
   * Локальный бэк сохраняет новую строку в `redemption_requests.txt` со статусом `PENDING`, формируя запись:

     ```
     <requestId>;<merchantId>;<amount>;<requesterId>;<dateTime>;<status>
     ```
   * Возвращает ФП статус «успешно» или «ошибка».
   * ФП показывает сообщение: «Запрос на гашение успешно отправлен руководителю» (если OK), иначе «Ошибка при сохранении запроса: …».
   * Обновляет список текущих заявок (новый GET `/api/finance/redemption-requests`).

4. **Просмотр текущих заявок, истории и баланса**:

   * **Список текущих заявок**: отрисовывается таблица (`<table>`) с колонками: «ID заявки», «Мерчант», «Сумма», «Дата/время», «Статус».
   * **Список проведённых гашений**: таблица с колонками: «ID», «Мерчант», «Сумма», «Дата/время».
   * **Список проведённых эмиссий**: аналогично («ID эмиссии», «Мерчант», «Сумма», «Дата/время»).

     * История гашений и эмиссий хранится в одном файле `history.txt`, где каждая строка содержит:

       ```
       <type>;<recordId>;<merchantId>;<amount>;<dateTime>
       ```

       где `<type>` принимает значения `REDEMPTION` или `EMISSION`.
   * **Баланс**: находится через прокси-запрос `/api/finance/balance` к ПШ, возвращает JSON `{ balance: <число> }`. Отображается на экране в виде текста: «Баланс: <число> ЕД».

#### 3.3.2. UI-описание

* **Страница «Гашение ЭД»** (`/finance/redemption`):

  * **Заголовок**: «Функционал гашения (Финансист)».
  * **Блок «Текущий баланс»**:

    * Текст «Баланс: <число> ЕД» (крупным шрифтом).
  * **Форма «Новый запрос на гашение»**:

    * Поле «Сумма»: `<input type="number" min="0" step="0.01">`.
    * Поле «Мерчант»: `<select>` с опциями, загруженными из `merchants.txt`.
    * Кнопка «Провести гашение».
    * При наведении на элементы – тултиры с пояснениями, обязательность полей отмечена «\*».
  * **Таблица «Текущие заявки на гашение»**:

    * Колонки: «ID», «Мерчант», «Сумма», «Дата/время», «Статус (PENDING)».
    * Если статусов несколько (например, после одобрения руководителя статус меняется), отображать текстом.
  * **Таблица «История гашений»**:

    * Колонки: «ID», «Мерчант», «Сумма», «Дата/время».
    * Под таблицей пагинация (если > 20 записей).
  * **Таблица «История эмиссий»**:

    * Аналогичные колонки, разделённая секция (можно табами: Гашения / Эмиссии).

#### 3.3.3. Локальные файлы (серверные)

* `merchants.txt`

  * Строки:

    ```
    <merchantId>;<merchantName>
    ```
  * Пример:

    ```
    M001;ООО «Торговая Сеть»
    M002;ИП «Петров С.»
    ```
* `redemption_requests.txt`

  * Формат:

    ```
    <requestId>;<merchantId>;<amount>;<requesterId>;<dateTime ISO>;<status>
    ```
  * Статус: `PENDING` (новые), после подтверждения руководителем статус меняется на `CONFIRMED` или удаляется из списка (если требуются разные правила).
* `history.txt`

  * Формат:

    ```
    <type>;<recordId>;<merchantId>;<amount>;<dateTime ISO>
    ```
  * `<type>` = `REDEMPTION` или `EMISSION`.
  * Каждая строка — отдельная запись.

---

### 3.4. Функционал руководителя (role = `supervisor`)

**Основная задача**: просмотр заявок на гашение, подтверждение гашений, а также просмотр истории и баланса.

#### 3.4.1. Сценарий использования

1. Руководитель авторизуется и открывает вкладку «Подтверждение гашения».

2. При загрузке страницы ФП делает запросы к локальному API ФП:

   1. `/api/supervisor/redemption-requests` → получить список текущих заявок (файл `redemption_requests.txt`).
   2. `/api/supervisor/history` → получить историю гашений и эмиссий (`history.txt`).
   3. `/api/supervisor/balance` → получить текущий баланс (через прокси в ПШ).

3. **Подтверждение гашения**:

   * В таблице «Текущие заявки» каждой строке соответствует кнопка «Подтвердить».
   * При нажатии «Подтвердить» ФП делает запрос `POST /api/supervisor/confirm-redemption` с телом `{ requestId, approverId }`.
   * Локальный бэк ФП:

     1. Находит заявку в `redemption_requests.txt` (по `requestId`).
     2. Делает запрос к API ПШ:

        ```
        POST https://payment-gateway.company/api/payments/redeem
        Headers: { Authorization: Bearer <PШ-токен> }
        Body: { merchantId, amount, requestId }
        ```
     3. В случае успешного ответа:

        * Удаляет строку из `redemption_requests.txt`.
        * Добавляет запись в `history.txt` c типом `REDEMPTION`.
     4. Если ошибка от ПШ (например, недостаточно средств), оставляет заявку в файле, возвращает ошибку с описанием.
   * Фронт показывает:

     * «Гашение `<requestId>` выполнено успешно»
     * Либо «Ошибка при гашении: <текст ошибки>».
   * После успешного подтверждения обновляет список текущих заявок (`GET /api/supervisor/redemption-requests`) и историю (`GET /api/supervisor/history`).

4. **Просмотр истории и баланса**:

   * Аналогично разделу Финансиста:

     * Таблица «История гашений» (type=REDEMPTION).
     * Таблица «История эмиссий» (type=EMISSION).
     * Текст «Баланс: <число> ЕД» (прокси-запрос в ПШ).

#### 3.4.2. UI-описание

* **Страница «Подтверждение гашения»** (`/supervisor/approvals`):

  * **Заголовок**: «Функционал гашения (Руководитель)».
  * **Блок «Текущий баланс»**: как у финансиста.
  * **Таблица «Запросы на гашение»**:

    * Колонки: «ID заявки», «Мерчант», «Сумма», «Дата/время», «Статус (PENDING)», «Действие».
    * В колонке «Действие» — кнопка «Подтвердить».
  * **Таблица «История гашений»**:

    * Колонки: «ID», «Мерчант», «Сумма», «Дата/время» (records типа `REDEMPTION`).
  * **Таблица «История эмиссий»**:

    * Колонки: «ID», «Мерчант», «Сумма», «Дата/время» (records типа `EMISSION`).
  * **Поведение**: при загрузке страницы показывать загрузочный индикатор, затем контент.

---

### 3.5. Общие требования к ФП

1. **Разделение доступа по ролям**

   * Менеджер не должен видеть интерфейсы «Гашение» и «Подтверждение», финансист не должен видеть загрузку платежей, руководитель не должен иметь доступ к загрузке платежей (если не входит в роль).
   * Главное меню (navbar) адаптивно скрывает/показывает пункты в зависимости от роли.

2. **Единое хранилище минимальных данных ФП**

   * ФП не имеет БД.
   * На сервере ФП (backend-часть ФП) в отдельных текстовых файлах хранятся:

     * `users.txt` — учётные записи пользователей:

       ```
       <userId>;<login>;<hashPassword>;<role>
       ```

       Пароли хранятся в виде хешей (например, SHA-256 или bcrypt), чтобы минимально обезопасить.
     * `uploaded_files.txt` — история загрузок менеджером.
     * `merchants.txt` — список мерчантов (финансист).
     * `redemption_requests.txt` — запросы на гашение (финансист/руководитель).
     * `history.txt` — история гашений/эмиссий (пройденные операции).
   * Серверная часть ФП отвечает на запросы к этим файлам и при необходимости взаимодействует с внешними API (ПШ, ЭК).

3. **Общие UI-компоненты**

   * **Layout**:

     * Header (логотип, название приложения, кнопка выхода).
     * Navbar или sidebar с пунктами меню; активный пункт выделяется.
     * Content area (динамически меняется в зависимости от роутера).
     * Footer (необязательно, небольшая строка с копирайтом/версией).
   * **Компоненты**:

     * `Button`, `Input`, `Select`, `Table`, `Modal/Dialog`, `Notification/Toast`, `Spinner`.
   * **Уведомления**:

     * При успехе/ошибке операций (Toast-уведомления).
     * Поля ввода должны показывать ошибки валидации («Поле обязательно», «Некорректный формат»).

4. **Валидация и защита**

   * Валидация на клиенте (JS) и на сервере (backend-ФП):

     * Проверка обязательных полей, диапазонов, форматов.
     * Сервер также проверяет токен и права.
   * Все запросы к ПШ/ЭК должны идти через backend ФП, чтобы не раскрывать ключи/токены внешних систем в клиенте.

5. **Логирование и отладка**

   * Backend ФП логирует ошибки работы с файлами и внешними API.
   * Frontend в режиме разработки (dev) логирует в консоль ключевые события (fetch-запросы, ответы, ошибки).

6. **Расширяемость**

   * Архитектура front-end разделена на модули (фичи):

     * `auth` (компоненты входа/реги),
     * `manager`,
     * `finance`,
     * `supervisor`,
     * `shared` (общие компоненты: Layout, UI-элементы).
   * При добавлении новой роли достаточно добавить новый модуль, новые роуты, новые API-эндпоинты и компоненты.

---

## 4. Нефункциональные требования

1. **Производительность**

   * Интерфейс должен загружаться не дольше 2 секунд при «холодном» старте.
   * Все AJAX-запросы (fetch/Axios) не дольше 1 секунды в среднем.

2. **Безопасность**

   * HTTPS для всех взаимодействий (клиент ↔ backend ФП, backend ФП ↔ ПШ/ЭК).
   * Хранение и проверка паролей только в зашифрованном/хешированном виде.
   * JWT-токен (или аналог) должен иметь ограниченный срок жизни (например, 2 часа).
   * Защита от XSS: экранировать все пользовательские данные, отображаемые в UI (имена файлов, мерчанты и т.д.).
   * Защита от CSRF: при работе в браузерах, помимо JWT, можно использовать заголовки `X-CSRF-Token`, либо на этапе входа отдавать CSRF-токен.

3. **Совместимость**

   * Поддержка современных браузеров (Chrome, Firefox, Edge и Safari последних двух мажорных версий).
   * Адаптивность: базовая отзывчивость (desktop/mobile), однако основная целевая аудитория — корпоративные пользователи на десктопах.

4. **Масштабируемость**

   * Несмотря на то что база ФП — текстовые файлы, нагрузка ожидается невысокая (несколько десятков пользователей одновременно). При росте объёмов можно мигрировать хранилище на простую СУБД (SQLite или MariaDB).

5. **Локализация**

   * Подача интерфейса на русском языке.
   * Возможность легко добавить другой язык (например, английский) — рекомендуется использовать i18n-библиотеку.

6. **Тестирование**

   * Настроить unit-тесты для критичных модулей фронта (проверка валидации, отображения компонентов) — например, Jest + React Testing Library (если React).
   * Для backend ФП — простые интеграционные тесты эндпоинтов (например, Mocha/Chai или любой фреймворк на Node.js).

---

## 5. Архитектурная структура приложения

### 5.1. Общее разделение на слои

```
┌───────────────────────────────────────────────────────────┐
│                       Клиентская часть                   │
│   (Front-End Web Application)                            │
│                                                           │
│   ┌───────────────────────────────────────────────────┐   │
│   │   1. UI / Компоненты (React/Vue/Angular)          │   │
│   │   ├── Страницы (Pages)                            │   │
│   │   │    ├─ Login.vue/jsx                           │   │
│   │   │    ├─ ManagerPayments.vue/jsx                  │   │
│   │   │    ├─ FinanceRedemption.vue/jsx                │   │
│   │   │    ├─ SupervisorApprovals.vue/jsx              │   │
│   │   │    └─ Dashboard.vue/jsx                        │   │
│   │   ├── Компоненты UI (Button, Input, Table, etc.)   │   │
│   │   ├── Сервисы/API (axios или fetch-обёртка)        │   │
│   │   ├── Маршрутизация (Vue Router / React Router)    │   │
│   │   ├── Состояние (Vuex/Pinia / Redux)               │   │
│   │   └── Стили (TailwindCSS / SCSS / CSS-modules)     │   │
│   └───────────────────────────────────────────────────┘   │
│                                                           │
│   ┌───────────────────────────────────────────────────┐   │
│   │  2. Сетевой уровень (HTTP/Axios/Fetch)            │   │
│   │     (отправка запросов к Backend ФП)              │   │
│   └───────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────┘
┌───────────────────────────────────────────────────────────┐
│                      Серверная часть                     │
│               (Back-End фронтового приложения)           │
│                                                           │
│   ┌───────────────────────────────────────────────────┐   │
│   │  3. REST-API ФП                                   │   │
│   │    (например, Node.js + Express / Koa / Fastify)  │   │
│   │                                                   │   │
│   │   ├─ /api/auth                                  │   │
│   │   │    └─ POST /api/auth/login                  │   │
│   │   │    └─ POST /api/auth/logout                 │   │
│   │   │    └─ GET  /api/auth/me (проверка токена)   │   │
│   │                                                   │   │
│   │   ├─ /api/manager                                │   │
│   │   │    └─ GET  /uploaded-files                   │   │
│   │   │    └─ POST /upload                           │   │
│   │                                                   │   │
│   │   ├─ /api/finance                                │   │
│   │   │    └─ GET  /merchants                        │   │
│   │   │    └─ GET  /redemption-requests               │   │
│   │   │    └─ GET  /history                           │   │
│   │   │    └─ GET  /balance                           │   │
│   │   │    └─ POST /redemption-requests               │   │
│   │                                                   │   │
│   │   ├─ /api/supervisor                             │   │
│   │   │    └─ GET  /redemption-requests               │   │
│   │   │    └─ GET  /history                           │   │
│   │   │    └─ GET  /balance                           │   │
│   │   │    └─ POST /confirm-redemption                │   │
│   │                                                   │   │
│   │   ├─ Прокси к внешним серверам                   │   │
│   │   │    └─ ПШ (Payment Gateway)                    │   │
│   │   │    └─ ЭК  (Electronic Wallet)                 │   │
│   │                                                   │   │
│   │   ├─ Middleware                                 │   │
│   │   │    └─ Аутентификация (JWT)                   │   │
│   │   │    └─ Авторизация (role-based)               │   │
│   │   │    └─ Валидация на уровне API                │   │
│   │                                                   │   │
│   │   └─ Сервис работы с файлами на сервере          │   │
│   │        (чтение/запись `*.txt`)                   │   │
│   └───────────────────────────────────────────────────┘   │
│                                                           │
│   ┌───────────────────────────────────────────────────┐   │
│   │  4. Внешние системы                               │   │
│   │    (ПШ и ЭК)                                      │   │
│   │                                                   │   │
│   │   ├─ ПШ (Платежный шлюз)                         │   │
│   │   │    └─ API:                                    │   │
│   │   │         • POST /payments/batch-upload         │   │
│   │   │         • GET  /merchants                     │   │
│   │   │         • GET  /balance                       │   │
│   │   │         • POST /payments/redeem               │   │
│   │   │                                                   │   │
│   │   └─ ЭК (Электронный кошелек)                    │   │
│   │        └─ API:                                   │   │
│   │             • GET /wallet/payments                │   │
│   │             • другие эндпоинты по потребностям   │   │
│   └───────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────┘
```

### 5.2. Детализированная структура папок (пример для React + TypeScript)

```
/frontend/  
├─ public/  
│   └─ index.html  
├─ src/  
│   ├─ api/                    # Обёртки для запросов к backend ФП (axios/Fetc h)  
│   │    ├─ auth.ts  
│   │    ├─ manager.ts  
│   │    ├─ finance.ts  
│   │    ├─ supervisor.ts  
│   │    └─ index.ts            # Объединённый экспорт  
│   │  
│   ├─ assets/                 # Картинки, иконки, шрифты  
│   │    └─ logo.svg  
│   │  
│   ├─ components/             # Повторно используемые UI-компоненты  
│   │    ├─ Button/  
│   │    │    ├─ Button.tsx  
│   │    │    └─ Button.module.css  
│   │    ├─ Input/  
│   │    │    ├─ Input.tsx  
│   │    │    └─ Input.module.css  
│   │    ├─ Table/  
│   │    │    ├─ Table.tsx  
│   │    │    └─ Table.module.css  
│   │    ├─ Spinner/  
│   │    │    ├─ Spinner.tsx  
│   │    │    └─ Spinner.module.css  
│   │    └─ Notification/  
│   │         ├─ Notification.tsx  
│   │         └─ Notification.module.css  
│   │  
│   ├─ contexts/               # Контекст (AuthContext, ThemeContext и т.д.)  
│   │    └─ AuthContext.tsx  
│   │  
│   ├─ hooks/                  # Кастомные React-хуки (useAuth, useFetch и т.д.)  
│   │    ├─ useAuth.ts  
│   │    └─ useFetch.ts  
│   │  
│   ├─ layouts/                # Общие макеты страниц (Layout, ProtectedRoute)  
│   │    ├─ AppLayout.tsx  
│   │    └─ ProtectedRoute.tsx  
│   │  
│   ├─ pages/                  # Страницы приложения  
│   │    ├─ Login/              # Страница входа  
│   │    │    ├─ Login.tsx  
│   │    │    └─ Login.module.css  
│   │    ├─ Dashboard/          # Главная страница после входа  
│   │    │    ├─ Dashboard.tsx  
│   │    │    └─ Dashboard.module.css  
│   │    ├─ ManagerPayments/    # Страница менеджера (upload)  
│   │    │    ├─ ManagerPayments.tsx  
│   │    │    └─ ManagerPayments.module.css  
│   │    ├─ FinanceRedemption/  # Страница финансиста  
│   │    │    ├─ FinanceRedemption.tsx  
│   │    │    └─ FinanceRedemption.module.css  
│   │    └─ SupervisorApprovals/# Страница руководителя  
│   │         ├─ SupervisorApprovals.tsx  
│   │         └─ SupervisorApprovals.module.css  
│   │  
│   ├─ store/                  # Состояние (Redux или Context + reducer)  
│   │    ├─ index.ts            # Настройка хранилища, объединение редьюсеров  
│   │    ├─ authSlice.ts        # slice для авторизации  
│   │    └─ ...                  # другие slice’ы при необходимости  
│   │  
│   ├─ utils/                  # Вспомогательные функции (форматирование дат, helpers)  
│   │    └─ formatDate.ts  
│   │  
│   ├─ App.tsx                  # Точка входа приложения  
│   ├─ index.tsx                # Рендер React в DOM  
│   └─ react-app-env.d.ts       # Типы для CRA (если используется Create React App)  
│  
├─ package.json  
├─ tsconfig.json  
└─ vite.config.ts (или webpack.config.js)
```

---

## 6. Технологический стек и инструменты

### 6.1. Клиентская часть (Front-end)

1. **Язык и фреймворк**

   * **TypeScript + React** (рекомендация).

     * TypeScript обеспечивает статическую типизацию, снижение числа ошибок на этапе компиляции, удобство рефакторинга.
     * React (с React Router, Context/Redux) — одна из самых распространённых SPA-библиотек, активное сообщество и обилие готовых UI-компонентов.
   * **Альтернативы**:

     * Vue 3 + TypeScript (с Pinia, Vue Router)
     * Angular 13+ (на TypeScript; мощный, но более тяжеловесный)
   * **Выбор**: если команда уже знакома с Vue — можно взять Vue, иначе React более универсален.

2. **Управление состоянием**

   * **Redux Toolkit** (с createSlice, RTK Query)

     * Даст централизованное хранилище (авторизация, список файлов, запросов и т.д.).
   * **Context API + кастомные хуки** — для более лёгких проектов; можно хранить только auth-данные в Context, а всю остальную логику вынести в query-библиотеки.

3. **Маршрутизация**

   * **React Router v6** (или Vue Router, если Vue).
   * Маршруты:

     * `/login` → LoginPage (публичный).
     * `/dashboard` → DashboardPage (protected).
     * `/manager/payments` → ManagerPaymentsPage (role=manager).
     * `/finance/redemption` → FinanceRedemptionPage (role=finance).
     * `/supervisor/approvals` → SupervisorApprovalsPage (role=supervisor).
     * `*` → страница 404 или перенаправление.

4. **UI-библиотека и стилизация**

   * **Tailwind CSS** (утилитарный CSS-фреймворк)

     * Быстрый старт, адаптивность, настраиваемая тема.
   * **или** **Material-UI (MUI)**

     * Готовые компоненты, стилизация через тему, иконки.
   * Если нужен гибкий набор UI-контролов с собственным дизайном — Tailwind; если хочется «из коробки» набор готовых компонентов (таблицы, формы) — MUI.
   * **CSS-модули** (если требуется полная изоляция CSS).

5. **HTTP-клиент**

   * **Axios**

     * Простой в настройке, удобная обработка ошибок, запросов, интерсепторы для токена.
   * **или** Fetch API + wrapper (с собственной обёрткой для обработки ошибок и JSON).

6. **Аутентификация и авторизация**

   * **JWT** (JsonWebToken)

     * Backend ФП выдаёт JWT при логине; фронт хранит в `sessionStorage` (или `cookie HttpOnly`).
     * Axios интерсепторы добавляют `Authorization: Bearer <token>`.
   * **Защита роутов** через компонент `ProtectedRoute`, проверяющий наличие токена и соответствие роли.

7. **Валидация форм**

   * **React Hook Form** + **Yup** (для схем валидации)

     * Лёгкая интеграция, минимальные перерисовки при вводе.
   * **или** Formik + Yup.

8. **Уведомления и всплывающие сообщения**

   * **React-Toastify** (или аналоги)

     * Простая интеграция, настраиваемые тосты.

9. **Тестирование (опционально)**

   * **Jest** + **React Testing Library** (unit и интеграционные тесты компонентов).
   * **ESLint** + **Prettier** (статический анализ кода и форматирование).

10. **Сборка и инструменты**

    * **Vite** (или Create React App, Next.js).

      * Vite даёт более быстрый dev-сервер и быструю сборку.
    * **Поддержка ENV-переменных** (`.env`, `.env.production`).
    * **Git** (связь с GitHub/GitLab).

---

### 6.2. Серверная часть ФП (Back-end)

1. **Платформа**

   * **Node.js** (v16+) + **Express** (или **Fastify/Koa**)

     * Лёгковесный, широко распространённый стек для построения REST API.

2. **Язык**

   * **TypeScript**

     * Позволяет типизировать эндпоинты, request/response, модели данных, снижает ошибки.

3. **Модули/пакеты**

   * **express** (сервер)
   * **jsonwebtoken** (для выдачи/проверки JWT)
   * **bcrypt** (или bcryptjs) (для хеширования паролей)
   * **multer** (для обработки multipart/form-data при загрузке файлов)
   * **fs/promises** (для асинхронной работы с файлами)
   * **axios** (для прокси-запросов к внешним (ПШ/ЭК) API)
   * **cors** (если фронт и бэк размещаются на разных доменах/портах)
   * **dotenv** (для конфигурации переменных окружения)
   * **Joi** (или Zod) для валидации входящих данных на backend.

4. **Организация кода**

   ```
   /backend/  
   ├─ src/  
   │   ├─ controllers/             # Логика эндпоинтов  
   │   │    ├─ authController.ts  
   │   │    ├─ managerController.ts  
   │   │    ├─ financeController.ts  
   │   │    └─ supervisorController.ts  
   │   │  
   │   ├─ services/                # Сервисы для работы с файлами и внешними API  
   │   │    ├─ fileService.ts         # Чтение/запись в .txt  
   │   │    ├─ paymentGatewayService.ts # Прокси-вызовы к ПШ  
   │   │    └─ walletService.ts        # Прокси-вызовы к ЭК  
   │   │  
   │   ├─ middleware/              # middleware: аутентификация, авторизация, обработка ошибок  
   │   │    ├─ authMiddleware.ts  
   │   │    ├─ roleMiddleware.ts  
   │   │    └─ errorMiddleware.ts  
   │   │  
   │   ├─ models/                  # Описания интерфейсов/типов  
   │   │    ├─ userModel.ts  
   │   │    ├─ fileModels.ts  
   │   │    └─ requestModels.ts  
   │   │  
   │   ├─ routes/                  # Маршруты express  
   │   │    ├─ authRoutes.ts  
   │   │    ├─ managerRoutes.ts  
   │   │    ├─ financeRoutes.ts  
   │   │    └─ supervisorRoutes.ts  
   │   │  
   │   ├─ utils/                   # Утилиты (генерация ID, формат дат, хеширование паролей)  
   │   │    └─ utils.ts  
   │   │  
   │   ├─ index.ts                 # Точка входа: настройка express, подключение роутов  
   │   └─ config.ts                # Конфигурация (пути к файлам, адреса ПШ/ЭК, JWT_SECRET, пр.)  
   │  
   ├─ data/                        # Папка для текстовых файлов (в репозитории не хранить реальные пароли!)  
   │    ├─ users.txt  
   │    ├─ uploaded_files.txt  
   │    ├─ merchants.txt  
   │    ├─ redemption_requests.txt  
   │    └─ history.txt  
   │  
   ├─ package.json  
   ├─ tsconfig.json  
   └─ .env                         # Переменные окружения (JWT_SECRET, API_KEYS)  
   ```

5. **Основные эндпоинты (REST)**

* **Auth** (`authController.ts`):

  * `POST /api/auth/login`

    * Вход: `{ login, password }`.
    * Логика: проверить по `users.txt`, сравнить хеши, сгенерировать JWT `{ userId, role }`.
    * Ответ: `{ token, user: { userId, role, login } }`.
  * `GET /api/auth/me`

    * Проверка JWT, возвращает `{ userId, role, login }`.
  * `POST /api/auth/logout`

    * (Опционально) Черный список токенов, или удалить JWT на клиенте.

* **Manager** (`managerController.ts`):

  * `GET /api/manager/uploaded-files`

    * Читает `uploaded_files.txt`, парсит и возвращает массив объектов `[ { fileName, date, uploaderId, status, total, errors } ]`.
  * `POST /api/manager/upload`

    * Принимает multipart/form-data с полем `file`.
    * Сохраняет файл во временную папку, затем проксирует в API ПШ.
    * После ответа от ПШ: обновляет `uploaded_files.txt`, возвращает результат.

* **Finance** (`financeController.ts`):

  * `GET /api/finance/merchants`

    * Читает `merchants.txt`, возвращает `[ { merchantId, merchantName } ]`.
  * `GET /api/finance/redemption-requests`

    * Читает `redemption_requests.txt`, возвращает `[ { requestId, merchantId, amount, requesterId, dateTime, status } ]`.
  * `GET /api/finance/history`

    * Читает `history.txt`, возвращает весь массив с разделением по типу (`REDEMPTION`/`EMISSION`).
  * `GET /api/finance/balance`

    * Делает прокси-запрос к ПШ: `GET https://payment-gateway.company/api/balance?userId=<userId>`.
  * `POST /api/finance/redemption-requests`

    * Принимает тело `{ merchantId, amount, requesterId }`.
    * Формирует `requestId = <UUID>`, записывает в `redemption_requests.txt` строку.
    * Возвращает `{ success: true, requestId }` или `{ success: false, message }`.

* **Supervisor** (`supervisorController.ts`):

  * `GET /api/supervisor/redemption-requests`

    * То же, что и у финансиста (текущие заявки).
  * `GET /api/supervisor/history`

    * Аналогично история (то же, что и в finance).
  * `GET /api/supervisor/balance`

    * Прокси-запрос к ПШ (как у финансиста).
  * `POST /api/supervisor/confirm-redemption`

    * Принимает `{ requestId, approverId }`.
    * Ищет заявку в `redemption_requests.txt`; если не найдена — ошибка.
    * Делает `POST` в ПШ: `https://payment-gateway.company/api/payments/redeem` с `{ merchantId, amount, requestId }`.
    * Если ответ ПШ OK: удаляет строку из `redemption_requests.txt`, добавляет запись в `history.txt`:

      ```
      REDEMPTION;<newRecordId>;<merchantId>;<amount>;<dateTimeISO>
      ```
    * Возвращает `{ success: true }` или `{ success: false, message }`.

6. **Работа с файлами**

   * Использовать асинхронные методы `fs/promises`: `readFile`, `writeFile`, `appendFile`.
   * При одновременном доступе (несколько пользователей) — важно блокировать файл на запись (можно обрабатывать последовательно, либо использовать временный файл + атомарную замену).
   * Формат всех файлов: текстовый с разделителем `;`. При чтении — парсить строку на поля `split(';')`.

7. **Конфигурация и секреты**

   * Файл `.env` (не коммитить в репозиторий) содержит:

     ```
     JWT_SECRET=<сложная строка>
     PAYMENT_GATEWAY_BASE_URL=https://payment-gateway.company/api
     WALLET_BASE_URL=https://electronic-wallet.company/api
     PORT=4000
     ```
   * В `config.ts` считывать и валидировать наличие этих переменных.

---

## 7. Описание API взаимодействия

### 7.1. Прокси-запросы к «Платежному шлюзу» (ПШ)

* **Base URL:** `https://payment-gateway.company/api`
* **Требуется Authorization Header:** `Bearer <PШ_API_TOKEN>` (хранится в `.env`, backend ФП прикрепляет автоматически).

1. **Batch Upload Payments**

   ```
   POST /payments/batch-upload
   Headers:
     Content-Type: multipart/form-data
     Authorization: Bearer <PШ_TOKEN>
   Body:
     file: <файл с платежами>
   Response:
     {
       success: true,
       uploadedCount: 1234,
       errors: [ { row: 5, message: "Некорректный формат карты" }, ... ]
     }
   ```

   * При ответе с `success: false` в поле `errors` присылаются причины.

2. **Получить список мерчантов**

   ```
   GET /merchants
   Headers: { Authorization: Bearer <PШ_TOKEN> }
   Response:
     [
       { merchantId: "M001", merchantName: "ООО «Торговая Сеть»" },
       ...
     ]
   ```

3. **Получить баланс**

   ```
   GET /balance?userId=<userId>
   Headers: { Authorization: Bearer <PШ_TOKEN> }
   Response:
     { balance: 50000.25 }
   ```

4. **Провести гашение**

   ```
   POST /payments/redeem
   Headers: { Authorization: Bearer <PШ_TOKEN> }
   Body: {
     merchantId: "M001",
     amount: 15000.00,
     requestId: "REQ-123456"
   }
   Response:
     { success: true }
   Или:
     { success: false, message: "Недостаточно средств" }
   ```

### 7.2. Прокси-запросы к «Электронному кошельку» (ЭК)

* **Base URL:** `https://electronic-wallet.company/api`
* **Authorization:** при необходимости (если ЭК требует тот же или иной токен, хранится в `.env`).

1. **Получить данные о платежах**

   ```
   GET /wallet/payments?userId=<userId>
   Headers: { Authorization: Bearer <ЭК_TOKEN> }
   Response:
     [
       { paymentId: "P1001", amount: 123.45, date: "2025-06-03T12:34:56", status: "COMPLETED" },
       ...
     ]
   ```

   * Этот вызов нужен, если на экране менеджера (или другого роли) требуется просмотреть детали платежей, хранящихся в БД ЭК.

*Примечание:* если функционал показа платежей из ЭК не требуется прямо сейчас, можно оставить заготовку для будущего расширения.

---

## 8. Структура и организация фронтового приложения

### 8.1. Модули (фичи)

1. **Auth**

   * **Pages:** `LoginPage`
   * **Компоненты:** `LoginForm`
   * **Store/Slice:** `authSlice` (токен, информация о пользователе)
   * **Service/API:** `authApi` (login, me)

2. **ManagerPayments**

   * **Pages:** `ManagerPaymentsPage`
   * **Компоненты:**

     * `UploadedFilesTable` (таблица истории загрузок)
     * `UploadForm` (форма загрузки файла)
     * `UploadResult` (блок с результатом последней загрузки)
   * **Service/API:** `managerApi` (getUploadedFiles, uploadFile)
   * **Store/Slice:** `managerSlice` (uploadedFiles, lastUploadResult, loading)

3. **FinanceRedemption**

   * **Pages:** `FinanceRedemptionPage`
   * **Компоненты:**

     * `BalanceDisplay` (блок баланса)
     * `RedemptionForm` (форма создания заявки)
     * `RedemptionRequestsTable` (таблица текущих заявок)
     * `HistoryTable` (таблица истории гашений/эмиссий)
   * **Service/API:** `financeApi` (getMerchants, getRedemptionRequests, getHistory, getBalance, createRedemptionRequest)
   * **Store/Slice:** `financeSlice` (merchants, redemptionRequests, history, balance)

4. **SupervisorApprovals**

   * **Pages:** `SupervisorApprovalsPage`
   * **Компоненты:**

     * `BalanceDisplay` (тот же компонент, что у финансиста)
     * `PendingRequestsTable` (таблица запросов с кнопками «Подтвердить»)
     * `HistoryTable` (таблица истории гашений/эмиссий)
   * **Service/API:** `supervisorApi` (getRedemptionRequests, getHistory, getBalance, confirmRedemption)
   * **Store/Slice:** `supervisorSlice` (pendingRequests, history, balance)

5. **Shared (общие компоненты и утилиты)**

   * **Layout:** `AppLayout` (Header + Navbar + Footer + Outlet/Content)
   * **ProtectedRoute** — компонент-обёртка для охраны роутов (проверка токена + роли).
   * **UI-компоненты:**

     * `Button`, `Input`, `Select`, `Table`, `Spinner`, `Notification`, `Modal`, `FormWrapper`.
   * **Утилиты:**

     * Функции для форматирования дат (`formatDate`), генерации UUID.

### 8.2. Навигация (роутинг)

* Использовать React Router (или Vue Router).
* **Пример для React Router v6:**

  ```tsx
  import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
  import LoginPage from './pages/Login/Login';
  import Dashboard from './pages/Dashboard/Dashboard';
  import ManagerPaymentsPage from './pages/ManagerPayments/ManagerPayments';
  import FinanceRedemptionPage from './pages/FinanceRedemption/FinanceRedemption';
  import SupervisorApprovalsPage from './pages/SupervisorApprovals/SupervisorApprovals';
  import ProtectedRoute from './layouts/ProtectedRoute';

  function App() {
    return (
      <BrowserRouter>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route
            path="/"
            element={
              <ProtectedRoute>
                <Dashboard />
              </ProtectedRoute>
            }
          >
            <Route index element={<Navigate to="dashboard" />} />
            <Route path="dashboard" element={<Dashboard />} />

            {/* Менеджер */}
            <Route
              path="manager/payments"
              element={
                <ProtectedRoute roles={['manager']}>
                  <ManagerPaymentsPage />
                </ProtectedRoute>
              }
            />

            {/* Финансист */}
            <Route
              path="finance/redemption"
              element={
                <ProtectedRoute roles={['finance']}>
                  <FinanceRedemptionPage />
                </ProtectedRoute>
              }
            />

            {/* Руководитель */}
            <Route
              path="supervisor/approvals"
              element={
                <ProtectedRoute roles={['supervisor']}>
                  <SupervisorApprovalsPage />
                </ProtectedRoute>
              }
            />
          </Route>

          {/* Все прочие > 404 или перенаправление */}
          <Route path="*" element={<Navigate to="/login" replace />} />
        </Routes>
      </BrowserRouter>
    );
  }
  export default App;
  ```

### 8.3. Пример структуры папок на сервере

```
/backend/  
├─ src/  
│   ├─ controllers/  
│   │    ├─ authController.ts  
│   │    ├─ managerController.ts  
│   │    ├─ financeController.ts  
│   │    ├─ supervisorController.ts  
│   │    └─ ...  
│   │  
│   ├─ services/  
│   │    ├─ fileService.ts  
│   │    ├─ paymentGatewayService.ts  
│   │    └─ walletService.ts  
│   │  
│   ├─ middleware/  
│   │    ├─ authMiddleware.ts  
│   │    ├─ roleMiddleware.ts  
│   │    └─ errorMiddleware.ts  
│   │  
│   ├─ models/  
│   │    ├─ userModel.ts  
│   │    ├─ fileModels.ts  
│   │    └─ requestModels.ts  
│   │  
│   ├─ routes/  
│   │    ├─ authRoutes.ts  
│   │    ├─ managerRoutes.ts  
│   │    ├─ financeRoutes.ts  
│   │    └─ supervisorRoutes.ts  
│   │  
│   ├─ utils/  
│   │    └─ utils.ts  
│   │  
│   ├─ config.ts  
│   └─ index.ts  
│  
├─ data/  
│   ├─ users.txt  
│   ├─ uploaded_files.txt  
│   ├─ merchants.txt  
│   ├─ redemption_requests.txt  
│   └─ history.txt  
│  
├─ package.json  
├─ tsconfig.json  
└─ .env  
```

---

## 9. Дополнительные рекомендации по технологиям

1. **Контейнеризация (опционально)**

   * Можно упаковать backend и frontend в Docker-контейнеры для упрощения деплоя:

     * `Dockerfile` для frontend (сборка `npm run build` + nginx).
     * `Dockerfile` для backend (Node.js + запуск `npm run start`).
   * Составить `docker-compose.yml` для локальной разработки.

2. **CI/CD**

   * Настроить GitHub Actions (или GitLab CI) для:

     * Линтинга (`npm run lint`)
     * Запуска тестов (`npm run test`)
     * Сборки и деплоя (автоматическая сборка образа при пуше в main).

3. **Мониторинг и логирование**

   * Backend: логировать запросы (morgan или Winston).
   * Ошибки сохранять в отдельный файл `error.log`.
   * При расширении можно подключить сервисы мониторинга (Sentry, Loggly).

4. **Документация API**

   * Генерировать OpenAPI (Swagger) для REST API backend ФП:

     * Использовать `swagger-jsdoc` + `swagger-ui-express`.
     * Позволит разработчикам быстро смотреть и тестировать эндпоинты.

5. **Кэширование (опционально)**

   * Если список мерчантов или другие «статические» данные редко меняются, можно кешировать на backend ФП в памяти (или Redis) с TTL 5–10 минут.
   * Это снизит нагрузку на чтение файлов и внешний API ПШ.

6. **Обработка ошибок и UX**

   * На фронте: окна с понятными сообщениями об ошибках (например, «Ошибка подключения к серверу», «Недостаточно средств»).
   * Backend: консистентная структура ошибок `{ success: false, message: "Текст ошибки" }`.

---

## 10. Расширяемость и сопровождение

1. **Добавление новых ролей**

   * Добавить новую роль в `users.txt` и в `config.ts` (если требуется).
   * Создать новый модуль (компоненты и API) под новую роль.
   * В `ProtectedRoute` добавить проверку на новую роль.
   * В Navbar добавить новый пункт, видимый только для новой роли.

2. **Добавление новых функциональностей**

   * Определить новый endpoint в backend (`routes` → `controllers` → `services` → `fileService`/`paymentGatewayService`).
   * Добавить новые файлы (в `data/`, если нужен локальный storage).
   * На фронте: создать новую страницу и компоненты, использовать `fetch`/`axios` через `api`-слой.
   * Добавить новый slice/store (или расширить существующие).

3. **Миграция с файлового хранилища на СУБД**

   * При росте данных и требований удобнее перевести хранение из `.txt` в SQLite, PostgreSQL или MySQL.
   * Логика `fileService` перепишется на сервис для работы с БД (ORM: TypeORM/Prisma).

---

## 11. Итоговое резюме Технического Задания

1. **Название проекта:** Фронтовое веб-приложение для работы с «Платежным Шлюзом» и «Электронным Кошельком»

2. **Основная цель:** предоставить интерфейс для загрузки платежей, формирования и подтверждения запросов на гашение, просмотра истории операций и баланса, распределив функционал по ролям.

3. **Состав проекта:**

   * **Frontend** (SPA на React + TypeScript)
   * **Backend\_ФП** (Node.js + Express + TypeScript)
   * **Внешние API:** Платежный шлюз (Payment Gateway), Электронный кошелек (Electronic Wallet)
   * **Локальное файловое хранилище**: `users.txt`, `uploaded_files.txt`, `merchants.txt`, `redemption_requests.txt`, `history.txt`.

4. **Основные модули ФП:**

   * `auth` (вход/выход, проверка токена)
   * `managerPayments` (загрузка платежей)
   * `financeRedemption` (запросы на гашение, история, баланс)
   * `supervisorApprovals` (подтверждение гашений, история, баланс)
   * `shared` (Layout, ProtectedRoute, UI-компоненты)

5. **Технологии Front-end:**

   * React + TypeScript
   * React Router v6
   * Redux Toolkit (или Context)
   * Axios (fetch)
   * Tailwind CSS (или MUI)
   * React Hook Form + Yup
   * React-Toastify
   * Vite (или CRA)

6. **Технологии Back-end:**

   * Node.js + Express + TypeScript
   * JWT для аутентификации
   * bcrypt для хеширования паролей
   * multer для загрузки файлов
   * fs/promises для работы с локальными `.txt`
   * Axios (прокси)
   * Joi/Zod для валидации данных
   * dotenv для переменных окружения

7. **Нефункциональные требования:**

   * Безопасность (HTTPS, JWT, CSRF, XSS)
   * Производительность (быстрый отклик, минимальные задержки)
   * Совместимость с современными браузерами
   * Масштабируемость (возможность перехода на СУБД)
   * Локализация (поддержка i18n)
   * Тестирование (unit, интеграционные)

8. **План реализации (этапы):**

   1. Согласовать функциональные требования с заказчиком/стейкхолдерами.
   2. Подготовить макеты (wireframes) основных страниц (Login, Dashboard, Manager, Finance, Supervisor).
   3. Настроить репозитории (frontend/backend), CI/CD, окружения dev/stage/prod.
   4. Реализовать backend ФП:

      * Аутентификацию, чтение/запись файлов, прокси к ПШ/ЭК, эндпоинты.
      * Покрыть unit-тестами бизнес-логику работы с файлами.
   5. Реализовать frontend:

      * Страницы входа, ProtectedRoute, layout, navbar.
      * Модули по ролям (менеджер, финансист, руководитель).
      * Валидацию, уведомления, spinner’ы, обработку ошибок.
      * Тесты компонентов (Jest + RTL).
   6. Интеграционное тестирование: проверки «end-to-end» (например, вручную или с Cypress).
   7. Подготовить документацию (README, Swagger/OpenAPI для backend).
   8. Деплой:

      * Собрать frontend (npm run build) и задеплоить на сервер (nginx или CDN).
      * Запустить backend ФП на Node.js (PM2 или Docker).
   9. Передать инструкцию по эксплуатации + обучить ключевых пользователей.

---

## 12. Предложение по структуре приложения

Ниже приведена сводная таблица рекомендуемой структуры и технологий:

| Слой / Модуль            | Описание                                                                                                      | Инструменты/Технологии                        |
| ------------------------ | ------------------------------------------------------------------------------------------------------------- | --------------------------------------------- |
| **Front-end**            | SPA для взаимодействия с пользователем                                                                        | React, TypeScript, Vite                       |
| └─ **Pages**             | Отдельные экраны: Login, Dashboard, ManagerPayments, FinanceRedemption, SupervisorApprovals                   | React Router v6                               |
| └─ **Components**        | UI-контролы: Button, Input, Select, Table, Spinner, Notification, Modal                                       | Tailwind CSS (или MUI), React Hook Form + Yup |
| └─ **State Management**  | Хранилище состояния (авторизация, данные по ролям, списки)                                                    | Redux Toolkit (или ContextAPI)                |
| └─ **API Layer**         | Обёртка над `axios`, интерсепторы для JWT, функции для каждого эндпоинта                                      | Axios                                         |
| └─ **Utilities & Hooks** | Функции форматирования, кастомные хуки (useAuth, useFetch)                                                    | TypeScript, Lodash (по необходимости)         |
| **Back-end (ФП)**        | REST API для работы с фронтом и прокси к внешним системам                                                     | Node.js, Express, TypeScript                  |
| └─ **Controllers**       | Логика обработки запросов (Auth, Manager, Finance, Supervisor)                                                | Express                                       |
| └─ **Services**          | Работа с файлами (`fs/promises`), прокси к ПШ (`axios`), прокси к ЭК                                          | `fs/promises`, Axios                          |
| └─ **Middleware**        | JWT-аутентификация, проверка ролей, глобальная обработка ошибок                                               | jsonwebtoken, bcrypt, Express middleware      |
| └─ **Data Storage**      | Текстовые файлы: `users.txt`, `uploaded_files.txt`, `merchants.txt`, `redemption_requests.txt`, `history.txt` | Простые `.txt` в папке `/data`                |
| └─ **Validation**        | Проверка входящих данных (логин/пароль, тело запросов)                                                        | Joi или Zod                                   |
| └─ **Документация API**  | Генерация Swagger/OpenAPI для документирования REST эндпоинтов                                                | swagger-jsdoc, swagger-ui-express             |
| **Внешние системы**      | ПШ и ЭК: предоставляют API для загрузки платежей, получения мерчантов, баланса, гашения                       | HTTPS, JSON                                   |

---

## 13. Резюме предложенных технологий

1. **Frontend**

   * **React** + **TypeScript**
   * Маршрутизация: **React Router v6**
   * Состояние: **Redux Toolkit** (RTK Query при необходимости)
   * HTTP-клиент: **Axios**
   * UI-библиотека: **Tailwind CSS** (возможен MUI)
   * Формы: **React Hook Form** + **Yup**
   * Уведомления: **React-Toastify**
   * Сборка: **Vite** (быстрый dev-сервер)
   * Тесты: **Jest** + **React Testing Library**

2. **Backend (ФП)**

   * **Node.js** (v16+) + **Express**
   * **TypeScript** (с `ts-node-dev` в dev-режиме)
   * Хеширование паролей: **bcrypt**
   * JWT-аутентификация: **jsonwebtoken**
   * Загрузка файлов: **multer**
   * Работа с файлами: **fs/promises**
   * Прокси к внешним API: **axios**
   * Валидация входных данных: **Joi** или **Zod**
   * Документация API: **swagger-jsdoc** + **swagger-ui-express**
   * Переменные окружения: **dotenv**

3. **Инфраструктура**

   * **Docker** (контейнеризация frontend/backend)
   * **Docker Compose** (для локальной разработки)
   * **CI/CD**: GitHub Actions (линг, тестирование, сборка, деплой)
   * **Сервер деплоя**: Linux-сервер + Nginx (frontend) + PM2 (backend) или Kubernetes (при необходимости масштабирования)

4. **Хранение данных**

   * **Локальные текстовые файлы** (из требований проекта)
   * Возможность миграции в СУБД (SQLite, PostgreSQL) при росте проекта

---

## 14. Дополнительные замечания и рекомендации

* **Безопасность паролей**: даже если хранение паролей организовано в текстовом файле, используйте надёжный хеш-функции (bcrypt с солью), а сами файлы храните вне публичных директорий (например, в папке `data/` с ограниченным доступом).
* **Возможность масштабирования**: продумайте структуру сервисов (controller → service → file/db → API), чтобы в будущем, при переходе с файлового хранилища на СУБД, нужно было минимально переписать слои.
* **Стандарт имен**: придерживайтесь единого стиля кодирования (ESLint + Prettier) для фронта и бэка.
* **Логгирование**: на сервере логируйте не только ошибки доступа к файлам и внешним API, но и ключевые действия (загрузка файла, создание/подтверждение запросов).
* **Документация**: создайте README.md для frontend и backend с описанием команд (`npm install`, `npm run dev`, `npm run build`, `npm start`) и краткими инструкциями по настройке `.env`.

---

**Заключение**
Данное Техническое Задание содержит подробное описание функциональных и нефункциональных требований, архитектуры, структуры проекта, рекомендуемых технологий и последовательности этапов разработки. Соблюдение этих рекомендаций позволит создать модульное, расширяемое и безопасное фронтовое веб-приложение, которое будет удобно сопровождать и дополнять новыми возможностями по мере развития бизнеса.
